#!/usr/bin/env python

import json
import logging
import math
import os
import re
import shutil
import subprocess

# --- НАСТРОЙКИ ---
TARGET_SIZE_BYTES = 1920 * 1024 * 1024
OFFSET_SIZE_BYTES = 50 * 1024 * 1024
BATCH_SIZE = 10

LOG_FILE = "batch_grouper.log"

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[logging.FileHandler(LOG_FILE), logging.StreamHandler()],
)


def natural_sort_key(s: str):
    return [
        int(text) if text.isdigit() else text.lower() for text in re.split(r"(\d+)", s)
    ]


def get_video_info(file_path: str):
    cmd = [
        "ffprobe",
        "-v",
        "error",
        "-show_entries",
        "format=duration,size",
        "-of",
        "json",
        file_path,
    ]
    result = subprocess.run(
        cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
    )
    if result.returncode != 0:
        return None
    try:
        data = json.loads(result.stdout)
        return {
            "duration": float(data["format"]["duration"]),
            "size": int(data["format"]["size"]),
        }
    except:
        return None


def split_by_size_sequential(file_path: str, backup_dir: str) -> bool:
    info = get_video_info(file_path)
    if not info:
        logging.error(f"Не удалось прочитать {file_path}")
        return False

    total_duration = info["duration"]
    file_size = info["size"]

    if file_size < (TARGET_SIZE_BYTES + OFFSET_SIZE_BYTES):
        logging.info(f"[ОК] {file_path} (Total: {file_size / 1024 / 1024:.2f} MB)")
        return False

    base_name = os.path.splitext(os.path.basename(file_path))[0]
    directory = os.path.dirname(file_path)

    current_start_time = 0.0
    part_num = 0

    logging.info(f"[РЕЖЕМ] {base_name} (Total: {file_size / 1024 / 1024:.2f} MB)")

    while current_start_time < (total_duration - 1):
        output_filename = f"{base_name} - part {part_num:03d}.mp4"
        output_path = os.path.join(directory, output_filename)

        cmd = [
            "ffmpeg",
            "-ss",
            str(current_start_time),
            "-i",
            file_path,
            "-c",
            "copy",
            "-fs",
            str(TARGET_SIZE_BYTES),
            "-y",
            output_path,
        ]

        _ = subprocess.run(
            cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=True
        )

        part_info = get_video_info(output_path)
        if not part_info:
            logging.error(f"Ошибка создания части {output_path}")
            break

        chunk_duration = part_info["duration"]
        chunk_size_mb = part_info["size"] / (1024 * 1024)

        logging.info(
            f" -> Part {part_num}: {chunk_size_mb:.2f} MB, длительность: {chunk_duration:.2f} сек."
        )

        if chunk_duration < 1.0:
            if os.path.exists(output_path):
                os.remove(output_path)
            break

        current_start_time += chunk_duration
        part_num += 1

        if chunk_duration < 10 and part_info["size"] > TARGET_SIZE_BYTES * 0.9:
            logging.warning(
                "Странное поведение: кусок короткий, но полный. Возможно ошибка seek."
            )

    _ = shutil.move(file_path, os.path.join(backup_dir, os.path.basename(file_path)))
    return True


def main():
    current_dir = os.getcwd()
    backup_dir = os.path.join(current_dir, "_ORIGINALS_BACKUP")
    os.makedirs(backup_dir, exist_ok=True)

    logging.info("=== ЭТАП 1: Умная нарезка по размеру (-fs) ===")

    files = sorted(
        [
            f
            for f in os.listdir(current_dir)
            if f.lower().endswith(".mp4")
            and " - part " not in f
            and os.path.isfile(os.path.join(current_dir, f))
        ],
        key=natural_sort_key,
    )

    for file in files:
        file_path = os.path.join(current_dir, file)
        _ = split_by_size_sequential(file_path, backup_dir)

    logging.info("=== ЭТАП 2: Группировка по папкам ===")

    final_files = sorted(
        [
            f
            for f in os.listdir(current_dir)
            if f.lower().endswith(".mp4")
            and os.path.isfile(os.path.join(current_dir, f))
        ],
        key=natural_sort_key,
    )

    if not final_files:
        logging.info("Нет файлов для группировки.")
        return

    total_batches = math.ceil(len(final_files) / BATCH_SIZE)

    for i in range(total_batches):
        batch_num = i + 1
        batch_folder_name = f"Upload_Batch_{batch_num:02d}"
        batch_folder_path = os.path.join(current_dir, batch_folder_name)
        os.makedirs(batch_folder_path, exist_ok=True)

        batch_files = final_files[i * BATCH_SIZE : (i + 1) * BATCH_SIZE]

        logging.info(f"Группа {batch_folder_name}:")
        if batch_files:
            logging.info(f" -> {batch_files[0]} ... {batch_files[-1]}")

        for filename in batch_files:
            src = os.path.join(current_dir, filename)
            dst = os.path.join(batch_folder_path, filename)
            _ = shutil.move(src, dst)

    logging.info("=== Готово! ===")


if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        logging.error(f"Критическая ошибка: {e}")

#!/usr/bin/env python

import json
import logging
import math
import os
import shutil
import subprocess

# --- НАСТРОЙКИ ---
HARD_LIMIT_MB = 1950  # Лимит Телеграма
CALC_TARGET_MB = 1400  # Целевой размер куска (с запасом)
BATCH_SIZE = 10  # Количество видео в одном посте (группе)

LOG_FILE = "batch_grouper.log"

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[logging.FileHandler(LOG_FILE), logging.StreamHandler()],
)


def get_video_info(file_path):
    cmd = [
        "ffprobe",
        "-v",
        "error",
        "-show_entries",
        "format=duration,size",
        "-of",
        "json",
        file_path,
    ]
    result = subprocess.run(
        cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
    )

    if result.returncode != 0:
        return None
    try:
        data = json.loads(result.stdout)
        return {
            "duration": float(data["format"]["duration"]),
            "size": int(data["format"]["size"]),
        }
    except:
        return None


def main():
    current_dir = os.getcwd()

    # Папка для бекапа оригиналов (тех, что мы порезали)
    backup_dir = os.path.join(current_dir, "_ORIGINALS_BACKUP")
    os.makedirs(backup_dir, exist_ok=True)

    logging.info("=== ЭТАП 1: Проверка и нарезка ===")

    # 1. Сначала обрабатываем все файлы
    # Берем только файлы в текущей папке (не лезем в подпапки)
    files = sorted(
        [
            f
            for f in os.listdir(current_dir)
            if f.lower().endswith(".mp4")
            and os.path.isfile(os.path.join(current_dir, f))
        ]
    )

    for file in files:
        file_path = os.path.join(current_dir, file)
        info = get_video_info(file_path)

        if not info:
            logging.warning(f"Не удалось прочитать: {file}")
            continue

        size_mb = info["size"] / (1024 * 1024)

        if size_mb > HARD_LIMIT_MB:
            logging.info(f"[РЕЖЕМ] {file} ({size_mb:.2f} MB)")

            num_parts = math.ceil(size_mb / CALC_TARGET_MB)
            part_duration = info["duration"] / num_parts

            base_name = os.path.splitext(file)[0]
            output_pattern = f"{base_name} - part %03d.mp4"

            split_cmd = [
                "ffmpeg",
                "-i",
                file_path,
                "-f",
                "segment",
                "-segment_time",
                str(part_duration),
                "-reset_timestamps",
                "1",
                "-c",
                "copy",
                output_pattern,
                "-y",
            ]

            try:
                subprocess.run(split_cmd, check=True)
                logging.info(" -> Успешно нарезан.")

                # Перемещаем огромный оригинал в бекап, чтобы он не попал в отправку
                shutil.move(file_path, os.path.join(backup_dir, file))
                logging.info(f" -> Оригинал перемещен в {backup_dir}")

            except subprocess.CalledProcessError as e:
                logging.error(f"Ошибка при резке {file}: {e}")
        else:
            logging.info(f"[OK] {file} ({size_mb:.2f} MB) - не требует резки.")

    logging.info("=== ЭТАП 2: Группировка по папкам ===")

    # Сканируем папку заново, чтобы увидеть новые части
    # Исключаем сам скрипт и папки
    final_files = sorted(
        [
            f
            for f in os.listdir(current_dir)
            if f.lower().endswith(".mp4")
            and os.path.isfile(os.path.join(current_dir, f))
        ]
    )

    if not final_files:
        logging.info("Нет файлов для группировки.")
        return

    # Разбиваем список на куски по 10
    total_batches = math.ceil(len(final_files) / BATCH_SIZE)

    for i in range(total_batches):
        batch_num = i + 1
        batch_folder_name = f"Upload_Batch_{batch_num:02d}"
        batch_folder_path = os.path.join(current_dir, batch_folder_name)

        os.makedirs(batch_folder_path, exist_ok=True)

        # Получаем срез файлов для текущей группы
        start_index = i * BATCH_SIZE
        end_index = start_index + BATCH_SIZE
        batch_files = final_files[start_index:end_index]

        logging.info(
            f"Создание группы {batch_folder_name} ({len(batch_files)} файлов)..."
        )

        for filename in batch_files:
            src = os.path.join(current_dir, filename)
            dst = os.path.join(batch_folder_path, filename)
            shutil.move(src, dst)

    logging.info("=== Готово! ===")
    logging.info("Файлы разложены по папкам 'Upload_Batch_XX'.")
    logging.info("Большие оригиналы сохранены в '_ORIGINALS_BACKUP'.")


if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        logging.error(f"Критическая ошибка: {e}")
